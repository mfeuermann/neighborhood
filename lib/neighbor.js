// Generated by CoffeeScript 1.6.2
(function() {
  var LocalObject, LocalProcess, Neighbor, RemoteObject, RemoteObjects, RemoteProcess, Socket, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  utils = require('./utils');

  Socket = require('./socket').Socket;

  RemoteObject = require('./remoteobject').RemoteObject;

  LocalObject = require('./localobject').LocalObject;

  RemoteProcess = require('./objects/process').RemoteProcess;

  LocalProcess = require('./objects/process').LocalProcess;

  RemoteObjects = {
    RemoteProcess: RemoteProcess,
    LocalProcess: LocalProcess
  };

  Neighbor = (function(_super) {
    __extends(Neighbor, _super);

    Neighbor.prototype.authorized = false;

    Neighbor.prototype.neighborhood = null;

    Neighbor.prototype.localObjects = null;

    Neighbor.prototype.remoteObjects = null;

    function Neighbor(neighborhood, socket) {
      this.neighborhood = neighborhood;
      Neighbor.__super__.constructor.call(this, socket);
      this.localObjects = {};
      this.remoteObjects = {};
      this.on('connect', this.handshake.bind(this));
      this.on('close', this.clear.bind(this));
    }

    Neighbor.prototype.clear = function() {
      var guid, object, _ref, _ref1, _results;

      _ref = this.localObjects;
      for (guid in _ref) {
        object = _ref[guid];
        object.destroy();
      }
      _ref1 = this.remoteObjects;
      _results = [];
      for (guid in _ref1) {
        object = _ref1[guid];
        _results.push(object.destroy());
      }
      return _results;
    };

    Neighbor.prototype.handshake = function() {
      var _this = this;

      return this.call('handshake', this.neighborhood.name, function(err, name) {
        if (err) {
          _this.emit('error', err);
          return _this.close();
        }
        _this.name = name;
        return _this.emit('authorize');
      });
    };

    Neighbor.prototype.onHandshake = function(name, callback) {
      var _this = this;

      this.name = name;
      this.authorized = true;
      if (typeof callback === "function") {
        callback(null, this.neighborhood.name);
      }
      return process.nextTick(function() {
        return _this.emit('authorize');
      });
    };

    Neighbor.prototype.createRemoteObject = function(object, callback) {
      if (object instanceof RemoteObject) {
        this.remoteObjects[object.guid] = object;
        return this.call('createRemoteObject', object.guid, object.constructor.name, callback);
      }
    };

    Neighbor.prototype.onCreateRemoteObject = function(guid, type, callback) {
      type = "Local" + (type.substr(6));
      if (RemoteObjects[type]) {
        this.localObjects[guid] = new RemoteObjects[type](guid, this);
        if (callback) {
          return callback(null);
        } else {
          return this.dispatchRemoteEvent(guid, 'create');
        }
      } else {
        if (callback) {
          return callback(new Error("Unknown remote object: " + type + "!"));
        } else {
          return this.dispatchRemoteEvent(guid, 'error', new Error("Unknown remote object: " + type + "!"));
        }
      }
    };

    Neighbor.prototype.destroyRemoteObject = function(object) {
      if (object instanceof RemoteObject) {
        delete this.remoteObjects[object.guid];
        return this.call('destroyRemoteObject', object.guid);
      }
    };

    Neighbor.prototype.onDestroyRemoteObject = function(guid) {
      this.localObjects[object.guid].destroy();
      return delete this.localObjects[object.guid];
    };

    Neighbor.prototype.dispatchRemoteEvent = function(guid, event) {
      return this.call.apply(this, ['dispatchRemoteEvent'].concat(__slice.call(arguments)));
    };

    Neighbor.prototype.onDispatchRemoteEvent = function() {
      var args, event, guid, _ref;

      guid = arguments[0], event = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (this.remoteObjects[guid]) {
        return (_ref = this.remoteObjects[guid]).emit.apply(_ref, [event].concat(__slice.call(args)));
      }
    };

    Neighbor.prototype.callRemoteFunction = function(guid, name) {
      if (this.remoteObjects[guid]) {
        return this.call.apply(this, ['callRemoteFunction'].concat(__slice.call(arguments)));
      }
    };

    Neighbor.prototype.onCallRemoteFunction = function() {
      var args, guid, name, _ref;

      guid = arguments[0], name = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (this.localObjects[guid]) {
        if (this.localObjects[guid][name]) {
          return (_ref = this.localObjects[guid][name]).call.apply(_ref, [this.localObjects[guid]].concat(__slice.call(args)));
        } else {
          return this.call('dispatchRemoteEvent', guid, 'error', new Error("Function " + name + " not found on remote object."));
        }
      } else {
        return this.call('dispatchRemoteEvent', guid, 'error', new Error("Shared object " + guid + " not found."));
      }
    };

    return Neighbor;

  })(Socket);

  exports.Neighbor = Neighbor;

  exports.RemoteObjects = RemoteObjects;

}).call(this);
