// Generated by CoffeeScript 1.6.2
(function() {
  var EventEmitter, HEADER_LENTGH, Socket, SocketError, capitalize, deserialize, deserializeArguments, net, serialize, serializeArguments, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  utils = require('./utils');

  net = require('net');

  EventEmitter = require('events').EventEmitter;

  HEADER_LENTGH = 8;

  serialize = function(data) {
    var header, packet;

    header = new Buffer(HEADER_LENTGH);
    header.write('nbrh');
    header.writeUInt32LE(0, 4);
    data = new Buffer(JSON.stringify(data));
    packet = Buffer.concat([header, data]);
    packet.writeUInt32LE(packet.length, 4);
    return packet;
  };

  deserialize = function(data) {
    var ex, packet;

    try {
      packet = data.toString('utf8', HEADER_LENTGH);
      return JSON.parse(packet);
    } catch (_error) {
      ex = _error;
      return null;
    }
  };

  capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  serializeArguments = function(args) {
    var arg, i, _i, _len, _results;

    _results = [];
    for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
      arg = args[i];
      if (arg instanceof Error) {
        _results.push(args[i] = {
          __error__: {
            message: arg.message,
            type: arg.name
          }
        });
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  deserializeArguments = function(args) {
    var arg, i, klass, _i, _len, _ref, _results;

    _results = [];
    for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
      arg = args[i];
      if (arg != null ? arg.__error__ : void 0) {
        if (arg.__error__.type === 'SocketError') {
          klass = SocketError;
        } else {
          klass = (_ref = global[arg.__error__.type]) != null ? _ref : Error;
        }
        _results.push(args[i] = new klass(arg.__error__.message));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Socket = (function(_super) {
    __extends(Socket, _super);

    Socket.prototype._callbacks = null;

    Socket.prototype.name = 'socket';

    Socket.prototype.connected = false;

    function Socket(socket) {
      var buffer, currentPacketLength,
        _this = this;

      this.socket = socket;
      if (this.socket) {
        this.connected = true;
      } else {
        this.socket = socket = new net.Socket;
      }
      buffer = new Buffer(0);
      currentPacketLength = 0;
      this._callbacks = {};
      socket.on('connect', function() {
        _this.connected = true;
        return _this.emit('connect');
      });
      socket.on('close', function() {
        var cb, guid, wasConnected, _ref;

        wasConnected = _this.connected;
        _this.connected = false;
        buffer = null;
        currentPacketLength = 0;
        _this.emit('close', wasConnected);
        _ref = _this._callbacks;
        for (guid in _ref) {
          cb = _ref[guid];
          cb(new SocketError("Connection was lost!"));
        }
        return _this._callbacks = {};
      });
      socket.on('error', function(err) {
        return _this.emit('error', err);
      });
      socket.on('data', function(data) {
        var parsed, _results;

        buffer = Buffer.concat([buffer, data]);
        _results = [];
        while (true) {
          if (currentPacketLength === 0) {
            if (buffer.length > HEADER_LENTGH) {
              if (buffer.toString('utf8', 0, 4) !== 'nbrh') {
                _this.emit('error', new SocketError('Received data with invalid header! Clearing buffer.'));
                buffer = new Buffer(0);
                break;
              }
              currentPacketLength = buffer.readInt32LE(4);
            } else {
              break;
            }
          }
          if (currentPacketLength > 0) {
            if (buffer.length >= currentPacketLength) {
              parsed = deserialize(buffer.slice(0, currentPacketLength));
              if (parsed) {
                (function(parsed) {
                  var args, cb, cbid, cmd, last, _ref;

                  deserializeArguments(parsed.args);
                  if (parsed.cmd === '__callback__') {
                    cbid = parsed.args.shift();
                    args = parsed.args;
                    _this.emit('info', ("[sck:cb] <- (" + cbid + ", " + (args.join(', ')) + ")").cyan);
                    if (_this._callbacks[cbid]) {
                      _this._callbacks[cbid].apply(_this, args);
                      return delete _this._callbacks[cbid];
                    } else {
                      return _this.emit('error', new SocketError('Received callback with unknown cbID.'));
                    }
                  } else {
                    last = (_ref = parsed.args) != null ? _ref[parsed.args.length - 1] : void 0;
                    cb = last != null ? last.__callback__ : void 0;
                    if (cb) {
                      last = parsed.args[parsed.args.length - 1] = function() {
                        return _this.call.apply(_this, ['__callback__', cb].concat(__slice.call(arguments)));
                      };
                      last.toString = function() {
                        return "[callback]";
                      };
                    }
                    _this.emit('info', ("[sck:call] <- " + parsed.cmd + " (" + (parsed.args.join(', ')) + ")").cyan);
                    cmd = "on" + (capitalize(parsed.cmd));
                    if (_this[cmd]) {
                      return _this[cmd].apply(_this, parsed.args);
                    } else if (last instanceof Function) {
                      return last(new SocketError("Function " + cmd + " not found on socket!"));
                    }
                  }
                })(parsed);
              }
              buffer = buffer.slice(currentPacketLength);
              _results.push(currentPacketLength = 0);
            } else {
              break;
            }
          } else {
            break;
          }
        }
        return _results;
      });
    }

    Socket.prototype.close = function() {
      return this.socket.end();
    };

    Socket.prototype.connect = function(host, port, callback) {
      return this.socket.connect(port, host, callback);
    };

    Socket.prototype.call = function() {
      var args, cbid, cmd, data, last;

      cmd = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      serializeArguments(args);
      if (cmd !== '__callback__') {
        last = args[args.length - 1];
        if (last instanceof Function) {
          if (!this.connected) {
            return last(new SocketError("Connection is not established!"));
          }
          cbid = utils.guid();
          this._callbacks[cbid] = last;
          args[args.length - 1] = {
            __callback__: cbid,
            toString: function() {
              return '[callback]';
            }
          };
        }
        if (this.connected) {
          this.emit('info', ("[sck:call] -> " + cmd + " (" + (args.join(', ')) + ")").cyan);
        }
      } else {
        if (this.connected) {
          this.emit('info', ("[sck:cb] -> (" + (args.join(', ')) + ")").cyan);
        }
      }
      if (!this.connected) {
        return;
      }
      data = serialize({
        cmd: cmd,
        args: args
      });
      return this.socket.write(data);
    };

    return Socket;

  })(EventEmitter);

  SocketError = (function(_super) {
    __extends(SocketError, _super);

    function SocketError(message) {
      this.name = this.constructor.name;
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }

    return SocketError;

  })(Error);

  exports.Socket = Socket;

  exports.SocketError = SocketError;

}).call(this);
